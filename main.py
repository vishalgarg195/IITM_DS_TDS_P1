"""
IITM BS Data Science Diploma
Tools in Data Science - Project 1
App: LLM Code Deployment
Host this FastAPI on Hugging Face (or EC2), receives JSON requests from IITM,
generates a minimal app via aipipe LLM, deploys/updates GitHub Pages,
handles revisions, and pings the evaluation API.
"""

from fastapi import FastAPI, Request
import uvicorn, os, json, subprocess, time, logging, requests
from pathlib import Path
import aipipe

# ---------------------------------------------------------
# Basic setup
# ---------------------------------------------------------
app = FastAPI()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

LOCAL_BASE = Path(".")
LOCAL_BASE.mkdir(parents=True, exist_ok=True)

GITHUB_USER = os.environ.get("GITHUB_USERNAME")
EXPECTED_SECRET = os.environ.get("EXPECTED_SECRET")
PERSONAL_ACCESS_TOKEN = os.environ.get("GH_TOKEN")

# ---------------------------------------------------------
# Helper: Wait for GitHub Pages to go live
# ---------------------------------------------------------
def wait_for_pages_ok(pages_url, max_attempts=25):
    for _ in range(max_attempts):
        try:
            r = requests.get(pages_url, timeout=5)
            if r.status_code == 200:
                logger.info(f"✅ Pages URL {pages_url} is 200 OK")
                return True
        except Exception:
            pass
        time.sleep(3)
    logger.warning(f"⚠️ Pages URL {pages_url} did not become live after waiting")
    return False

# ---------------------------------------------------------
# LLM code generation using aipipe
# ---------------------------------------------------------

def llm_generate_code_with_aipipe(brief, attachments=None, previous_code=None):
    """
    Generate app code via aipipe CLI.
    - brief: App brief from request
    - attachments: List of attachments (name + URL)
    - previous_code: Code from previous round (for Revise)
    Returns: HTML content string (or None on failure)
    """
    prompt_file = "/tmp/prompt.txt"

    # Prepare prompt
    attachment_info = ""
    if attachments:
        attachment_info = "\n".join([f"{att['name']}: {att['url'][:30]}..." for att in attachments])

    prompt_text = f"""
You are an AI assistant generating a minimal HTML+JS web app.
- App brief: {brief}
- Attachments info: {attachment_info}
- Previous code: {previous_code or 'None'}
- Produce a complete index.html with minimal JS.
- Also provide README.md summary and MIT LICENSE.
"""
    # Write prompt to file
    with open(prompt_file, "w") as f:
        f.write(prompt_text)

    # Run aipipe CLI
    try:
        result = subprocess.run(
            ["aipipe", "generate", "--prompt-file", prompt_file],
            capture_output=True,
            text=True,
            check=True
        )
        html_content = result.stdout.strip()
        logger.info("✅ aipipe generation successful")
        return html_content
    except subprocess.CalledProcessError as e:
        logger.error("⚠️ aipipe CLI failed")
        logger.error("stdout:\n%s", e.stdout)
        logger.error("stderr:\n%s", e.stderr)
        return None


# ---------------------------------------------------------
# GitHub helper: init repo, push, enable Pages
# ---------------------------------------------------------
def create_or_update_repo(task, html_content, round_idx=1):
    local_path = LOCAL_BASE / task
    if round_idx == 1:
        if local_path.exists():
            subprocess.run(["rm", "-rf", str(local_path)])
        local_path.mkdir(parents=True, exist_ok=True)
    else:
        if not local_path.exists():
            raise FileNotFoundError(f"Repo folder for task '{task}' does not exist for revise.")

    # Write files
    (local_path / "index.html").write_text(html_content, encoding="utf-8")
    (local_path / "README.md").write_text(f"# {task}\nRound {round_idx} auto-generated app.\n", encoding="utf-8")
    (local_path / "LICENSE").write_text("MIT License\n\nGenerated by IITM TDS Project 1 Script.", encoding="utf-8")

    # Git commands
    if round_idx == 1:
        subprocess.run(["git", "init"], cwd=local_path)
        subprocess.run(["git", "branch", "-M", "main"], cwd=local_path)
        subprocess.run(["git", "remote", "add", "origin",
                        f"https://{GITHUB_USER}:{PERSONAL_ACCESS_TOKEN}@github.com/{GITHUB_USER}/{task}.git"],
                       cwd=local_path)

    subprocess.run(["git", "add", "."], cwd=local_path)
    commit_msg = "Initial commit" if round_idx == 1 else f"Revise round {round_idx}"
    subprocess.run(["git", "commit", "-m", commit_msg], cwd=local_path)
    subprocess.run([
        "git", "push", "--force" if round_idx == 1 else "", 
        f"https://{GITHUB_USER}:{PERSONAL_ACCESS_TOKEN}@github.com/{GITHUB_USER}/{task}.git",
        "main"
    ], cwd=local_path)

    # Enable GitHub Pages
    api_url = f"https://api.github.com/repos/{GITHUB_USER}/{task}/pages"
    payload = {"source": {"branch": "main", "path": "/"}}
    requests.post(api_url, headers={"Authorization": f"token {PERSONAL_ACCESS_TOKEN}"}, json=payload)

    # Commit SHA & Pages URL
    commit_sha = subprocess.getoutput(f"git -C {local_path} rev-parse HEAD")
    pages_url = f"https://{GITHUB_USER}.github.io/{task}/"
    pages_live = wait_for_pages_ok(pages_url)
    return commit_sha, pages_url, pages_live

# ---------------------------------------------------------
# Notify evaluation API with retries
# ---------------------------------------------------------
def notify_evaluation(eval_url, payload):
    delay = 1
    for attempt in range(10):
        try:
            r = requests.post(eval_url, headers={"Content-Type": "application/json"}, json=payload)
            logger.info(f"Eval POST attempt {attempt + 1} -> {r.status_code}")
            if r.status_code == 200:
                return True
        except Exception as e:
            logger.warning(f"Eval POST attempt {attempt + 1} failed: {e}")
        time.sleep(delay)
        delay *= 2
    return False

# ---------------------------------------------------------
# API Endpoints
# ---------------------------------------------------------
@app.get("/")
def root():
    return {"status": "running", "message": "Hugging Face Docker Space is alive!"}

@app.get("/health")
def health():
    return {"ok": True}

@app.post("/api-endpoint")
async def api_endpoint(req: Request):
    try:
        data = await req.json()
        logger.info(f"Received request: {json.dumps(data, indent=2)}")

        # 1️⃣ Validate secret
        if data.get("secret") != EXPECTED_SECRET:
            return {"status": "error", "reason": "Invalid secret"}

        # 2️⃣ Extract fields
        task = data.get("task", "unnamed-task")
        brief = data.get("brief", "")
        attachments = data.get("attachments", [])
        round_idx = data.get("round", 1)
        eval_url = data.get("evaluation_url")
        email = data.get("email")
        nonce = data.get("nonce")



        # 3️⃣ Determine previous code if revise
        previous_code = None
        local_path = LOCAL_BASE / task
        if round_idx > 1 and local_path.exists() and (local_path / "index.html").exists():
            previous_code = (local_path / "index.html").read_text(encoding="utf-8")

        # 4️⃣ Generate or update app via LLM
        html_content = llm_generate_code_with_aipipe(brief, attachments, previous_code)

        # 5️⃣ Push to GitHub / Pages
        commit_sha, pages_url, pages_live = create_or_update_repo(task, html_content, round_idx)

        # 6️⃣ Notify evaluation API
        payload = {
            "email": email,
            "task": task,
            "round": round_idx,
            "nonce": nonce,
            "repo_url": f"https://github.com/{GITHUB_USER}/{task}.git",
            "commit_sha": commit_sha,
            "pages_url": pages_url,
        }
        notified = notify_evaluation(eval_url, payload) if eval_url else False

        return {
            "status": "ok",
            "task": task,
            "round": round_idx,
            "repo_url": payload["repo_url"],
            "commit_sha": commit_sha,
            "pages_url": pages_url,
            "pages_live": pages_live,
            "notified_evaluation": notified,
        }

    except Exception as e:
        logger.exception("Error processing request")
        return {"status": "error", "reason": str(e)}

# ---------------------------------------------------------
# Run server
# ---------------------------------------------------------
if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=int(os.environ.get("PORT", 7860)))
